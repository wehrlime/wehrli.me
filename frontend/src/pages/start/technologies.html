<h2>
  <!-- lang:en -->
  Technologies
  <!-- /lang:en -->
  <!-- lang:de -->
  Technologien
  <!-- /lang:de -->
</h2>
<p class="lead">
  <!-- lang:en -->

  Atwood's Law states, that "Any application that <i>can</i> be written in JavaScript,
  <i>will</i> eventually be written in JavaScript".
  <!-- /lang:en -->
  <!-- lang:de -->
  Atwoods Gesetz besagt, dass "jede Anwendung, die in JavaScript geschrieben werden <i>kann</i>,
  irgendwann in JavaScript geschrieben <i>wird</i>".
  <!-- /lang:de -->
</p>
<br />
<p class="max-width-900">
  <!-- lang:en -->
  I support this hypothesis.
  <!-- /lang:en -->
  <!-- lang:de -->
  Ich unterstütze diese Hypothese.
  <!-- /lang:de -->
</p>
<p class="max-width-900">
  <!-- lang:en -->
  JavaScript enables good user experience on the internet. It is accessible for everyone, runs in
  every browser on any computer and smartphone. Secure by default, no installation needed.
  <!-- /lang:en -->
  <!-- lang:de -->
  JavaScript ermöglicht ein gutes Nutzererlebnis im Internet. Es ist für jeden zugänglich, läuft in
  jedem Browser auf jedem Computer und Smartphone. Standardmäßig sicher, keine Installation
  erforderlich.
  <!-- /lang:de -->
</p>
<p class="max-width-900">
  <!-- lang:en -->
  This is why JavaScript and the technologies that emerged from it, like TypeScript, SPA frameworks
  and Node.js, are in my opinion the most important development that has happened to software
  engineering in the last three decades.
  <!-- /lang:en -->
  <!-- lang:de -->
  Deshalb sind JavaScript und die daraus entstandenen Technologien wie TypeScript, SPA-Frameworks
  und Node.js meiner Meinung nach die wichtigste Entwicklung, die in den letzten drei Jahrzehnten in
  der Softwareentwicklung stattgefunden hat.
  <!-- /lang:de -->
</p>
<p class="max-width-900">
  <!-- lang:en -->
  I solely rely on technologies that emerged from JavaScript, when building software.
  <!-- /lang:en -->
  <!-- lang:de -->
  Bei der Entwicklung von Software setze ich ausschließlich auf Technologien, die aus JavaScript
  hervorgegangen sind.
  <!-- /lang:de -->
</p>
<br /><br />
<div class="staggered-list">
  <div class="staggered-list__col">
    <div class="staggered-list-cell">
      <h3>Frontend</h3>
      <p>
        <!-- lang:en -->
        The front-end of a web application are the parts, which are executed within a browser.
        Either on a computer or on a smartphone. Users can interact with it and it loosely connects
        via so called APIs to the back-end, to fetch data from and sends data to it.
        <!-- /lang:en -->
        <!-- lang:de -->
        Das Frontend einer Webanwendung sind die Teile, die innerhalb eines Browsers ausgeführt
        werden. Entweder auf einem Computer oder auf einem Smartphone. Die Nutzer können damit
        interagieren, und es ist über so genannte APIs lose mit dem Back-End verbunden, um Daten von
        dort abzurufen und an es zu senden.
        <!-- /lang:de -->
      </p>
      <p>
        <!-- lang:en -->
        In the front-end <a href="https://angular.io/" target="_blank" title="Angular">Angular</a>,
        <a href="https://react.dev/" target="_blank" title="React">React</a> and
        <a href="https://vuejs.org/" target="_blank" title="Vue.js">Vue.js</a>
        are some of the technologies I use.
        <!-- /lang:en -->
        <!-- lang:de -->
        Im Frontend verwende ich unter anderem
        <a href="https://angular.io/" target="_blank" title="Angular">Angular</a>,
        <a href="https://react.dev/" target="_blank" title="React">React</a> und
        <a href="https://vuejs.org/" target="_blank" title="Vue.js">Vue.js</a>.
        <!-- /lang:de -->
      </p>
    </div>
    <div class="staggered-list-cell">
      <h3>Mobile apps</h3>
      <p>
        <!-- lang:en -->
        Mobile apps can be built with multiple technologies. Either native Apps in Java/Kotlin for
        Android or Objective-C/Swift for iOS. Native apps have the downside, that they have to be
        built twice. Once for each operating system.
        <!-- /lang:en -->
        <!-- lang:de -->
        Mobile Apps können mit verschiedenen Technologien erstellt werden. Entweder native Apps in
        Java/Kotlin für Android oder Objective-C/Swift für iOS. Native Apps haben den Nachteil, dass
        sie zweimal erstellt werden müssen. Einmal für jedes Betriebssystem.
        <!-- /lang:de -->
      </p>
      <p>
        <!-- lang:en -->
        Because I use JavaScript technologies, I use
        <a href="https://ionicframework.com/" target="_blank" title="Ionic Framework"
          >Ionic Framework</a
        >,
        <a href="https://reactnative.dev/" target="_blank" title="React Native">React Native</a> or
        <a href="https://nativescript.org/" target="_blank" title="NativeScript">NativeScript</a>
        instead, which are so called hybrid app frameworks.
        <!-- /lang:en -->
        <!-- lang:de -->
        Da ich JavaScript-Technologien verwende, setze ich stattdessen
        <a href="https://ionicframework.com/" target="_blank" title="Ionic Framework"
          >Ionic Framework</a
        >,
        <a href="https://reactnative.dev/" target="_blank" title="React Native">React Native</a>
        oder
        <a href="https://nativescript.org/" target="_blank" title="NativeScript">NativeScript</a>
        ein, also sogenannte Hybrid-App-Frameworks.
        <!-- /lang:de -->
      </p>
      <p>
        <!-- lang:en -->
        The biggest advantage of these frameworks is, that only one app needs to be built to support
        both iOS and Android. You are able to cut your timely and costly needs in half and only need
        one team to maintain the app.
        <!-- /lang:en -->
        <!-- lang:de -->
        Der größte Vorteil dieser Frameworks ist, dass nur eine App entwickelt werden muss, die
        sowohl iOS als auch Android unterstützt. Sie können Ihren Zeit- und Kostenaufwand halbieren
        und brauchen nur ein Team für die Wartung der App.
        <!-- /lang:de -->
      </p>
      <p>
        <!-- lang:en -->
        Well made hybrid apps are indistinguishable from native apps. Some well known hybrid apps
        are Gmail, Uber, Facebook or Instagram.
        <!-- /lang:en -->
        <!-- lang:de -->
        Gut gemachte Hybrid-Apps sind von nativen Apps nicht zu unterscheiden. Einige bekannte
        Hybrid-Apps sind Gmail, Uber, Facebook oder Instagram.
        <!-- /lang:de -->
      </p>
    </div>
    <div class="staggered-list-cell">
      <h3>
        <!-- lang:en -->
        Web server
        <!-- /lang:en -->
        <!-- lang:de -->
        Webserver
        <!-- /lang:de -->
      </h3>
      <p>
        <!-- lang:en -->
        As web server technology I use
        <a href="https://www.nginx.com/" target="_blank" title="Nginx">Nginx</a> or
        <a href="https://httpd.apache.org/" target="_blank" title="Apache">Apache</a> and Linux as
        operating system, depending on the available server.
        <!-- /lang:en -->
        <!-- lang:de -->
        Als Webservertechnologie verwende ich
        <a href="https://www.nginx.com/" target="_blank" title="Nginx">Nginx</a> oder
        <a href="https://httpd.apache.org/" target="_blank" title="Apache">Apache</a> und Linux als
        Betriebssystem, je nach verfügbarem Server.
        <!-- /lang:de -->
      </p>
      <p>
        <!-- lang:en -->
        For Node.js process management I use
        <a href="https://pm2.keymetrics.io/" target="_blank" title="pm2">pm2</a>.
        <!-- /lang:en -->
        <!-- lang:de -->
        Für die Node.js-Prozessverwaltung verwende ich
        <a href="https://pm2.keymetrics.io/" target="_blank" title="pm2">pm2</a>.
        <!-- /lang:de -->
      </p>
      <p>
        <!-- lang:en -->
        For scalable back-ends I use
        <a href="https://kubernetes.io/" target="_blank" title="Kubernetes">Kubernetes</a>.
        <!-- /lang:en -->
        <!-- lang:de -->
        Für skalierbare Backends verwende ich
        <a href="https://kubernetes.io/" target="_blank" title="Kubernetes">Kubernetes</a>.
        <!-- /lang:de -->
      </p>
    </div>
  </div>
  <div class="staggered-list__col">
    <div class="staggered-list-cell">
      <h3>Backend</h3>
      <p>
        <!-- lang:en -->
        The back-end is the part on a web application, which is executed on a server. It computes
        data, reads and writes to databases and is responsible to do things, that can not or should
        not be done in the front-end. Like, for example, user authentication.
        <!-- /lang:en -->
        <!-- lang:de -->
        Das Back-End ist der Teil einer Webanwendung, der auf einem Server ausgeführt wird. Es
        berechnet Daten, liest und schreibt in Datenbanken und ist für Dinge zuständig, die im
        Front-End nicht erledigt werden können oder sollen. Wie zum Beispiel die
        Benutzerauthentifizierung.
        <!-- /lang:de -->
      </p>
      <p>
        <!-- lang:en -->
        In the back-end I use JavaScript/TypeScript as well. Here these languages are used within
        <a href="https://nodejs.org/" target="_blank" title="Node.js">Node.js</a>, which is a
        runtime environment, that can execute
        <a href="https://en.wikipedia.org/wiki/JavaScript" target="_blank" title="JavaScript"
          >JavaScript</a
        >
        like a Browser.
        <!-- /lang:en -->
        <!-- lang:de -->
        Im Backend verwende ich ebenfalls JavaScript/TypeScript. Hier werden diese Sprachen
        innerhalb von
        <a href="https://nodejs.org/" target="_blank" title="Node.js">Node.js</a> verwendet, das
        eine Laufzeitumgebung ist, die
        <a href="https://en.wikipedia.org/wiki/JavaScript" target="_blank" title="JavaScript"
          >JavaScript</a
        >
        wie ein Browser ausführen kann.
        <!-- /lang:de -->
      </p>
      <p>
        <!-- lang:en -->
        As a Node.js framework I use
        <a href="https://nestjs.com/" target="_blank" title="NestJS">NestJS</a> or "plain" Node.js
        with <a href="https://expressjs.com/" target="_blank" title="Express.js">Express.js</a>.
        <!-- /lang:en -->
        <!-- lang:de -->
        Als Node.js-Framework verwende ich
        <a href="https://nestjs.com/" target="_blank" title="NestJS">NestJS</a> oder "einfaches"
        Node.js mit
        <a href="https://expressjs.com/" target="_blank" title="Express.js">Express.js</a>.
        <!-- /lang:de -->
      </p>
      <p>
        <!-- lang:en -->
        Node.js headless CMS' I use are
        <a href="https://strapi.io/" target="_blank" title="Strapi">Strapi</a> and
        <a href="https://ghost.org/" target="_blank" title="Ghost">Ghost</a>. The choice on which
        CMS to use varies between use cases.
        <!-- /lang:en -->
        <!-- lang:de -->
        Node.js Headless CMS, die ich verwende, sind
        <a href="https://strapi.io/" target="_blank" title="Strapi">Strapi</a> und
        <a href="https://ghost.org/" target="_blank" title="Ghost">Ghost</a>. Die Entscheidung,
        welches CMS verwendet wird, hängt von den jeweiligen Anwendungsfällen ab.
        <!-- /lang:de -->
      </p>
    </div>
    <div class="staggered-list-cell">
      <h3>
        <!-- lang:en -->
        Database
        <!-- /lang:en -->
        <!-- lang:de -->
        Datenbank
        <!-- /lang:de -->
      </h3>
      <p>
        <!-- lang:en -->
        To use relational database systems is the first choice for me. With SQL-like systems data
        relations can be depicted within the database structure, which makes the data more rigid.
        But if the use cases dictates it, I use key-value databases (noSQL) as well.
        <!-- /lang:en -->
        <!-- lang:de -->
        Die Verwendung relationaler Datenbanksysteme ist für mich die erste Wahl. Mit SQL-ähnlichen
        Systemen können Datenbeziehungen innerhalb der Datenbankstruktur abgebildet werden, was die
        Daten starrer macht. Aber wenn es der Anwendungsfall erfordert, verwende ich auch
        Key-Value-Datenbanken (noSQL).
        <!-- /lang:de -->
      </p>
      <p>
        <!-- lang:en -->
        I rely on ORMs (Object-relational mapper) like
        <a href="https://www.prisma.io/" target="_blank" title="Prisma">Prisma</a>,
        <a href="https://mikro-orm.io/" target="_blank" title="MikroORM">MikroORM</a> or
        <a href="https://typeorm.io/" target="_blank" title="TypeORM">TypeORM</a>.<br />Theses ORMs
        can manage a diverse range of databases, like
        <a href="https://www.sqlite.org/" target="_blank" title="SQLite">SQLite</a>,
        <a href="https://www.mysql.com/" target="_blank" title="MySQL">MySQL</a>,
        <a href="https://www.mongodb.com/" target="_blank" title="MongoDB">MongoDB</a>,
        <a href="https://www.postgresql.org/" target="_blank" title="PostgreSQL">PostgreSQL</a>,
        <a href="https://redis.io/" target="_blank" title="Redis">Redis</a> and more.
        <!-- /lang:en -->
        <!-- lang:de -->
        Ich setze auf ORMs (Object-relational mapper) wie
        <a href="https://www.prisma.io/" target="_blank" title="Prisma">Prisma</a>,
        <a href="https://mikro-orm.io/" target="_blank" title="MikroORM">MikroORM</a> oder
        <a href="https://typeorm.io/" target="_blank" title="TypeORM">TypeORM</a>. Diese ORMs können
        eine Vielzahl von Datenbanken verwalten, wie
        <a href="https://www.sqlite.org/" target="_blank" title="SQLite">SQLite</a>,
        <a href="https://www.mysql.com/" target="_blank" title="MySQL">MySQL</a>,
        <a href="https://www.mongodb.com/" target="_blank" title="MongoDB">MongoDB</a>,
        <a href="https://www.postgresql.org/" target="_blank" title="PostgreSQL">PostgreSQL</a>,
        <a href="https://redis.io/" target="_blank" title="Redis">Redis</a> und mehr.
        <!-- /lang:de -->
      </p>
    </div>
  </div>
</div>
